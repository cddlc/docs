{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>CDDL (Concise Data Definition Language) is a domain-specific language for describing the structure of CBOR (Concise Binary Object Representation) and JSON data. It provides a human-readable way to specify data schemas with precise type definitions, constraints, and validation rules.</p> <p><code>cddlc</code> is an experimental golang code generator for CDDL<sup>1</sup> based data schemas. It generates Go code for (de)serialization and validation of CBOR data structures.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Code Generation: Automatically generates Go structs and methods from CDDL schemas</li> <li>CBOR Support: Native support for CBOR serialization and deserialization</li> <li>Type Safety: Generates strongly-typed Go code with compile-time guarantees</li> <li>Validation: Built-in validation logic based on CDDL constraints</li> <li>Extensible: Supports custom types and validation rules</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p><code>cddlc</code> is particularly useful for:</p> <ul> <li>Protocol Implementation: Building CBOR-based network protocols</li> <li>Data Exchange: Creating reliable data interchange formats</li> <li>Configuration Files: Validating structured configuration data</li> <li>IoT Applications: Efficient data representation for resource-constrained devices</li> <li>API Development: Type-safe data contracts between services</li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>Define Schema: Write your data structure definition in CDDL</li> <li>Generate Code: Run <code>cddlc</code> to generate Go types and methods</li> <li>Integrate: Use the generated code in your Go applications</li> <li>Validate: Automatically validate data against your schema</li> </ol>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>person = {\n  name: text,\n  age: uint,\n  email: text,\n  ? address: text\n}\n</code></pre> <p>This CDDL definition generates Go structs with methods for marshaling, unmarshaling, and validation.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to start using <code>cddlc</code>? Check out our Installation Guide to get up and running, then explore the Language Reference to learn CDDL syntax and features.</p> <ol> <li> <p>Concise Data Definition Language (CDDL - RFC 8610) is a notational convention to express Concise Binary Object Representation (CBOR) and JSON Data Structures.\u00a0\u21a9</p> </li> </ol>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#executable","title":"Executable","text":""},{"location":"installation/#go-install-118","title":"go install (\u22651.18)","text":"<p><code>cddlc</code> is available as a standalone golang binary through go install.</p> <pre><code>go install github.com/HannesKimara/cddlc/cmd/cddlc@latest\n</code></pre> <p>The installation can be tested by running, </p> <pre><code>cddlc --help\n</code></pre> <p>which will print the help to the terminal.</p> <pre><code>NAME:\n   cddl - CDDL validator and code generator\n\nUSAGE:\n   cddl [global options] command [command options] [arguments...]\n\nCOMMANDS:\n   init           Initialize a new cddlc project\n   generate, gen  Generate code from definition file\n   doctor         Show information about the current build\n   help, h        Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --help, -h  show help (default: false)\n</code></pre>"},{"location":"installation/#go-library","title":"Go Library","text":"<p>The <code>cddlc</code> module exports go packages used for tokenizing and parsing <code>CDDL</code> documents. To get, run:</p> <pre><code>go get -u github.com/HannesKimara/cddlc\n</code></pre> <p>To parse a sample <code>CDDL</code> document to its AST representation </p> main.gofoo.cddl <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n\n    \"github.com/HannesKimara/cddlc/lexer\"\n    \"github.com/HannesKimara/cddlc/parser\"\n)\n\nfunc main() {\n    src, err := ioutil.ReadFile(\"foo.cddl\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    lex := lexer.NewLexer(string(src))\n    p := parser.NewParser(lex)\n    cddl, err := p.ParseFile()\n\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Found %d rules\\n\", cddl.Rules)\n}\n</code></pre> <pre><code>public-key = [24*24 byte]\n\nperson = {\n    name: tstr .size 3\n    age: (0..120)\n    address: $Address ; Address as a type plug\n    public-key: public-key\n}\n</code></pre>"},{"location":"builds/","title":"Intro - cddlc.json","text":"<p><code>cddlc</code> supports automating multi-file builds using the <code>cddlc build</code> command and a <code>cddlc.json</code> config file. To create a new cddlc project in the current folder run</p> <pre><code>cddlc init\n</code></pre> <p>This produces a <code>cddlc.json</code> file with a default build config</p> cddlc.json<pre><code>{\n    \"version\": \"1\",\n    \"plugins\": [],\n    \"builds\": [\n        {\n            \"package\": \"\",\n            \"src\": \".\",\n            \"output\": \"dist/\"\n        }\n    ],\n    \"options\": null\n}\n</code></pre>"},{"location":"language/","title":"Introduction","text":"<p>This section covers how to use <code>cddlc</code> to actually generate code from a definition file. It also explains some of the choices made in interpretation of the language. </p> <p>Throughout this section single file builds will be invoked by running <code>generate</code> command in the form</p> <pre><code>cddlc generate --source foo.cddl --out lib/foo_gen.go --package foo\n</code></pre> <p>where <code>foo.cddl</code> is the input file, <code>lib/foo_gen.go</code> is the generated Go file and <code>foo</code> is the name of the package.</p> <p>Tip</p> <p>For a full reference of cddl concepts and their level of support in <code>cddlc</code> skip to the references section.</p>"},{"location":"language/primitives/","title":"Primitives","text":"<p>The <code>CDDL</code> language supports some primitives as type constraints. These primitives - <code>uint</code>, <code>int</code>, <code>bytes</code>, <code>bstr</code>, <code>text</code>/<code>tstr</code> are directly translated to Go type declarations. </p> <p>From the definition file <code>primitives.cddl</code> containing the following content, </p> primitives.cddl<pre><code>name = tstr\nage = uint\npublic-key = bytes\naccount-balance = int\n</code></pre> <p>go code can be generated by invoking</p> <pre><code>cddlc generate --source primitives.cddl --out lib/primitives.go --package foo\n</code></pre> <p>This generates the declarations and validation methods. Since the types are directly enforced by the Go type checker, the Valid() methods return nil by default. All values are public by default with identifiers formatted as PascalCase.</p> primitives.go<pre><code>/*\n  File generated using `cddlc.exe gen`. DO NOT EDIT\n*/\n\npackage foo\n\n// (cddlc) Ident: name\ntype Name string\n\n// Valid evaluates type constraints on name and returns nil if valid \n// else it returns a list of validation errors\nfunc (name *Name) Valid() error {\n    return nil\n}\n\n// (cddlc) Ident: age\ntype Age uint\n\n// Valid evaluates type constraints on age and returns nil if valid \n// else it returns a list of validation errors\nfunc (age *Age) Valid() error {\n    return nil\n}\n\n// (cddlc) Ident: public-key\ntype PublicKey []byte\n\n// Valid evaluates type constraints on public-key and returns nil if valid \n// else it returns a list of validation errors\nfunc (public-key *PublicKey) Valid() error {\n    return nil\n}\n\n// (cddlc) Ident: account-balance\ntype AccountBalance int\n\n// Valid evaluates type constraints on account-balance and returns nil if valid \n// else it returns a list of validation errors\nfunc (account-balance *AccountBalance) Valid() error {\n    return nil\n}\n</code></pre>"},{"location":"language/reference/","title":"Reference","text":"<p>This section outlines a summary of all <code>CDDL</code> types, their level of support and their Go equivalents.</p> CDDL Parser Code Generation Go Equivalent Links <code>uint</code> \u2611 \u2611 <code>uint</code> Docs"},{"location":"language/sockets_plugs/","title":"Plugs/Socket","text":"<p>Names that start with a single <code>$</code> are <code>type sockets</code>, starting out as an empty type, and intended to be extended via <code>/=</code>.  Names that start with a double <code>$$</code> are <code>group sockets</code>, starting out as an empty group choice, and intended to be extended via <code>//=</code>.  In either case, it is not an error if there is no definition for a socket at all; this then means there is no way to satisfy the rule (i.e., the choice is empty). <sup>1</sup></p> <p>Below is an example of a group socket - <code>$$Location</code></p> plug_socket.cddl<pre><code>Person = (\n    name: tstr,\n    age: uint,\n\n    Location: $$Location\n)\n</code></pre> <p><code>cddlc</code> interpretes undefined plugs/sockets as Golang types that are defined in the same package as the generated file. In this case plugs/sockets are not differentiated and the generated output expects the plug/socket to be defined in the same package.</p> <p>Generating code from this using</p> <pre><code>cddlc generate --source plug_socket.cddl --out lib/plug_socket.go --package foo\n</code></pre> <p>exports the Go declarations in \"lib/plug_socket.go\". To satisfy the Location type in Go, a file with this declaration must be added. </p> lib/plug_socket.golib/prelude.go <pre><code>/*\n  File generated using `cddlc.exe gen`. DO NOT EDIT\n*/\n\npackage foo\n\n// (cddlc) Ident: Person\ntype Person struct {\n    Name     string\n    Age      uint\n    Location Location\n}\n\n// Valid evaluates type constraints on Person and returns nil if valid \n// else it returns a list of validation errors\nfunc (person *Person) Valid() error {\n    return nil\n}\n</code></pre> <pre><code>package foo\n\nimport \"time\"\n\ntype Planet int\n\nconst (\n    Mercury Planet = iota\n    Venus\n    Earth\n    Mars\n)\n\ntype Location struct {\n    Planet  Planet\n    Country string\n\n    FirstOpened time.Time\n}\n</code></pre> <ol> <li> <p>https://www.rfc-editor.org/rfc/inline-errata/rfc8610.html\u00a0\u21a9</p> </li> </ol>"},{"location":"language/values_fixed/","title":"Fixed Values","text":"<p>The four supported fixed value types are <code>nil</code>/<code>null</code>, <code>true</code>, <code>false</code></p> <p>From the definition file <code>fixed.cddl</code> containing the following content, </p> fixed.cddl<pre><code>null-type = null\ntrue-alt = true\nfalse-val = false\n</code></pre> <p>go code can be generated by invoking</p> <pre><code>cddlc generate --source fixed.cddl --out lib/fixed.go --package foo\n</code></pre> <p>This generates the declarations and validation methods. Since the types are directly enforced by the Go type checker, the Valid() methods return nil by default. All values are public by default with identifiers formatted as PascalCase.</p> fixed.go<pre><code>/*\n  File generated using `cddlc.exe gen`. DO NOT EDIT\n*/\n\npackage foo\n\n// (cddlc) Ident: null-type\ntype NullType nil\n\n// Valid evaluates type constraints on null-type and returns nil if valid \n// else it returns a list of validation errors\nfunc (null-type *NullType) Valid() error {\n    return nil\n}\n\n// (cddlc) Ident: true-alt\nvar TrueAlt = true\n\n// Valid evaluates type constraints on true-alt and returns nil if valid \n// else it returns a list of validation errors\nfunc (true-alt *TrueAlt) Valid() error {\n    return nil\n}\n\n// (cddlc) Ident: false-val\nvar FalseVal = false\n\n// Valid evaluates type constraints on false-val and returns nil if valid \n// else it returns a list of validation errors\nfunc (false-val *FalseVal) Valid() error {\n    return nil\n}\n</code></pre>"}]}